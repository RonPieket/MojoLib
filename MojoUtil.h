/*
 Copyright (c) 2013, Insomniac Games
 
 All rights reserved.
 
 Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
 following conditions are met:
 - Redistributions of source code must retain the above copyright notice, this list of conditions and the
 following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 following disclaimer in the documentation and/or other materials provided with the distribution.
 
 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED
 WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/**
 \file
 \author Ron Pieket \n<http://www.ItShouldJustWorkTM.com> \n<http://twitter.com/RonPieket>
 */
/* MojoLib is documented at: http://www.ItShouldJustWorkTM.com/mojolib/ */

// ---------------------------------------------------------------------------------------------------------------

#pragma once

// -- Standard Libs
#include <stdint.h>
#include <string.h>

/**
 \file MojoUtil.h
 Bits and pieces that make hashing easier.
 */

/**
 \ingroup group_util
 A modified FNV-1a algorithm.
 The modification consists of the processing of an additional '~' character at the end of the string. This
 improves distribution of series of strings that only differ by their last character, such as "string1",
 "string2".
 <br>Also, the function returns zero if the input pointer is NULL or the length is 0.
 \param s The zero terminated string to hash.
 \return A hash value.
 */
uint32_t MojoFnv32( const char* s );
/**
 \ingroup group_util
 A modified FNV-1a algorithm.
 The modification consists of the processing of an additional '~' character at the end of the string. This
 improves distribution of series of strings that only differ by their last character, such as "string1",
 "string2".
 <br>Also, the function returns zero if the input pointer is NULL or the length is 0.
 \param s The string to hash.
 \param count The number of characters.
 \return A hash value.
 */
uint32_t MojoFnv32( const char* s, int count );
/**
 \ingroup group_util
 A modified FNV-1a algorithm.
 The modification consists of the processing of an additional '~' character at the end of the string. This
 improves distribution of series of strings that only differ by their last character, such as "string1",
 "string2".
 <br>Also, the function returns zero if the input pointer is NULL or the length is 0.
 \param s The zero terminated string to hash.
 \return A hash value.
 */
uint64_t MojoFnv64( const char* s );
/**
 \ingroup group_util
 A modified FNV-1a algorithm.
 The modification consists of the processing of an additional '~' character at the end of the string. This
 improves distribution of series of strings that only differ by their last character, such as "string1",
 "string2".
 <br>Also, the function returns zero if the input pointer is NULL or the length is 0.
 \param s The string to hash.
 \param count The number of characters.
 \return A hash value.
 */
uint64_t MojoFnv64( const char* s, int count );

/**
 \ingroup group_util
 Substitute for std::max. Something in the libraries we use here at Insomniac causes a compile status if I use
 std::max
 \param[in] a First value
 \param[in] b Second value
 \return The larger of a and b.
 */
template< typename T >
T MojoMax( const T& a, const T& b ) { return a > b ? a : b; }

/**
 \ingroup group_util
 Substitute for std::min. Something in the libraries we use at Insomniac causes a compile status if I use std::min
 \param[in] a First value
 \param[in] b Second value
 \return The smaller of a and b.
 */
template< typename T >
T MojoMin( const T& a, const T& b ) { return a <= b ? a : b; }

/**
 \ingroup group_util
 Template to use an integer type directly as a hash code. The hash code must be well-distributed. Random numbers
 are good hash codes, and so are hashes generated by a FNV or CRC algorithm. MojoMap and MojoSet will use the
 value as-is and index the hash table with the key value.
 \note Value 0 is reserved and means Null. This marks an empty slot in the hash table.
 */
template< typename T >
class MojoHash
{
public:
  /**
   Default constructor will initialize a Null hash code
   \note Hash table algorithm counts on this constructor to mark empty slots in hash table.
   */
  MojoHash()
    : m_Key( 0 )
  {}

  /**
   Construct implicitly from type T
   */
  MojoHash( T key )
    : m_Key( key )
  {}

  /**
   Test equality.
   \param[in] other Value to compare
   \return true if equal.
   \note Hash table algorithm counts on this operator.
   */
  bool operator== ( const MojoHash& other ) const
  {
    return m_Key == other.m_Key;
  }

  /**
   Implicitly convert to type T.
   */
  operator T() const
  {
    return m_Key;
  }

  /**
   Return the unaltered value.
   \return Same value as the object was initialized with.
   \note Hash table algorithm counts on this function.
   */
  uint64_t GetHash() const
  {
    return m_Key;
  }

  /**
   Test for Null.
   Value 0 means Null, used to mark an empty slot in the hash table.
   \return true if Null.
   \note Hash table algorithm counts on this function.
   */
  bool IsHashNull() const
  {
    return m_Key == 0;
  }

private:
  T m_Key;
};

/**
 \ingroup group_util
 Template to use an integer type indirectly as a hash code. No assumptions are made about suitability for use as a
 hash code. Use this template if you have an integer identifier that is not well-distributed, such as an index.
 The template will compute a hash code by applying a modified FNV-1A algorithm.
 This, of course, incurs more processing overhead than the MojoHash template, which does no processing at all.
 \note Value 0 is reserved and means Null. This marks an empty slot in the hash table.
 */
template< typename T >
class MojoHashable
{
public:
  /**
   Default constructor will initialize a Null hash code
   \note Hash table algorithm counts on this constructor to mark empty slots in hash table.
   */
  MojoHashable()
  : m_Key( 0 )
  {}
  
  /**
   Construct implicitly from type T
   */
  MojoHashable( T key )
  : m_Key( key )
  {}
  
  /**
   Test equality.
   \param[in] other Value to compare
   \return true if equal.
   \note Hash table algorithm counts on this operator.
   */
  bool operator== ( const MojoHashable& other ) const
  {
    return m_Key == other.m_Key;
  }
  
  /**
   Automatically convert to type T.
   */
  operator T() const
  {
    return m_Key;
  }
  
  /**
   Compute hash code.
   \return MojoFnv64( &value, sizeof( value ) )
   \note Hash table algorithm counts on this function.
   */
  uint64_t GetHash() const
  {
    return MojoFnv64( ( const char* )&m_Key, sizeof( m_Key ) );
  }
  
  /**
   Test for Null.
   Value 0 means Null, used to mark an empty slot in the hash table.
   \return true if Null.
   \note Hash table algorithm counts on this function.
   */
  bool IsHashNull() const
  {
    return m_Key == 0;
  }
  
private:
  T m_Key;
};

/**
 \ingroup group_util
 Template to use a C-string as hash code. The template will compute a hash code by applying a modified FNV-1A
 algorithm. This incurs some processing overhead, especially for long strings. You may want to consider using
 MojoId if you want to index your hash tables with strings.
 \note A NULL pointer is considered a Null hash code, and is used to mark empty slots in the hash table.
 \warning C-string must NOT be the empty string: "".
 */
class MojoHashableCString
{
public:
  /**
   Default constructor will initialize a Null hash code
   \note Hash table algorithm counts on this constructor to mark empty slots in hash table.
   */
  MojoHashableCString()
  : m_Key( NULL )
  {}

  /**
   Construct implicitly from const char*
   */
  MojoHashableCString( const char* c_string )
  : m_Key( c_string )
  {}

  /**
   Test equality.
   \param[in] other Value to compare
   \return true if equal.
   \note Hash table algorithm counts on this operator.
   */
  bool operator== ( const MojoHashableCString& other ) const
  {
    return 0 == strcmp( m_Key, other.m_Key );
  }

  /**
   Implicitly convert to const char*.
   */
  operator const char*() const
  {
    return m_Key;
  }
  
  /**
   Compute hash code.
   \return MojoFnv64( value )
   \note Hash table algorithm counts on this function.
   */
  uint64_t GetHash() const
  {
    return MojoFnv64( m_Key );
  }

  /**
   Test for Null.
   NULL means Null, used to mark an empty slot in the hash table.
   \note Hash table algorithm counts on this function.
   \return true if Null.
   */
  bool IsHashNull() const
  {
    return m_Key == NULL || m_Key[ 0 ] == '\0';
  }

private:
  const char* m_Key;
};

// ---------------------------------------------------------------------------------------------------------------
